// Generated by LiveScript 1.2.0
(function(){
  var root, esprima, walk, programExample, getCallExpressions, main, slice$ = [].slice;
  root = typeof exports != 'undefined' && exports !== null ? exports : this;
  esprima = require('esprima');
  walk = require('acorn/util/walk');
  programExample = 'b = Math.sqrt(35)\nq = sad.dfjnkg.sdfa(4)\nr = wer(1)';
  getCallExpressions = root.getCallExpressions = function(programText){
    var output, x, covered, nonOverlappingMemberExpressions, i$, ref$, len$, node, isCovered, j$, ref1$, len1$, idx;
    output = [];
    walk.simple(esprima.parse(programText, {
      range: true
    }), {
      CallExpression: function(node){
        var callee, res$, k, ref$, v;
        res$ = {};
        for (k in ref$ = node.callee) {
          v = ref$[k];
          res$[k] = v;
        }
        callee = res$;
        callee.start == null && (callee.start = callee.range[0]);
        callee.end == null && (callee.end = callee.range[1]);
        return output.push(callee);
      }
    });
    return (function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = output).length; i$ < len$; ++i$) {
        x = ref$[i$];
        results$.push({
          start: x.start,
          end: x.end,
          text: slice$.call(programText, x.start, x.end).join('')
        });
      }
      return results$;
    }());
    return output;
    memberExpressions.sort(function(a, b){
      return a.end - a.start > b.end - b.start;
    });
    memberExpressions.reverse();
    covered = {};
    nonOverlappingMemberExpressions = [];
    for (i$ = 0, len$ = (ref$ = memberExpressions).length; i$ < len$; ++i$) {
      node = ref$[i$];
      isCovered = false;
      for (j$ = 0, len1$ = (ref1$ = (fn$())).length; j$ < len1$; ++j$) {
        idx = ref1$[j$];
        if (covered[idx] != null) {
          isCovered = true;
          break;
        }
      }
      if (isCovered) {
        continue;
      }
      for (j$ = 0, len1$ = (ref1$ = (fn1$())).length; j$ < len1$; ++j$) {
        idx = ref1$[j$];
        covered[idx] = true;
      }
      nonOverlappingMemberExpressions.push(node);
    }
    return nonOverlappingMemberExpressions;
    function fn$(){
      var i$, to$, results$ = [];
      for (i$ = node.start, to$ = node.end; i$ <= to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }
    function fn1$(){
      var i$, to$, results$ = [];
      for (i$ = node.start, to$ = node.end; i$ <= to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }
  };
  main = function(){
    return console.log(getCallExpressions(programExample));
  };
  if (require.main === module) {
    main();
  }
}).call(this);
