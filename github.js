// Generated by LiveScript 1.2.0
(function(){
  var root, querystring, http_get, async, nstore, repositories_db, codesearch_db, rootURL, fs, ref$, client_id, client_secret, wrapGH, wrapGHJSON, getRepositoriesRawUncached, getRepositoriesRaw, errWrap, getRepositories, searchCodeRawUncached, searchCodeRaw, sortCompare, searchCode, main, slice$ = [].slice;
  root = typeof exports != 'undefined' && exports !== null ? exports : this;
  querystring = require('querystring');
  http_get = require('http-request');
  async = require('async');
  nstore = require('nstore');
  repositories_db = nstore['new']('github_repositories.nstore');
  codesearch_db = nstore['new']('github_codesearch.nstore');
  rootURL = 'https://api.github.com';
  fs = require('fs');
  ref$ = JSON.parse(fs.readFileSync('github_client_secret.json', 'utf-8')), client_id = ref$.client_id, client_secret = ref$.client_secret;
  wrapGH = function(path, defaults, postprocess){
    defaults == null && (defaults = {});
    postprocess == null && (postprocess = function(x){
      return x;
    });
    defaults.client_id == null && (defaults.client_id = client_id);
    defaults.client_secret == null && (defaults.client_secret = client_secret);
    return function(properties, callback){
      var k, ref$, v, headers;
      for (k in ref$ = defaults) {
        v = ref$[k];
        if (properties[k] == null) {
          properties[k] = v;
        }
      }
      headers = properties.headers;
      if (headers == null) {
        headers = {};
      }
      console.log(rootURL + path + '?' + querystring.stringify(properties));
      return http_get.get({
        url: rootURL + path + '?' + querystring.stringify(properties),
        headers: headers
      }, function(err, data){
        return callback(
        postprocess(
        data.buffer.toString()));
      });
    };
  };
  wrapGHJSON = root.wrapGHJSON = function(path, defaults){
    return wrapGH(path, defaults, JSON.parse);
  };
  getRepositoriesRawUncached = root.getRepositoriesRawUncached = wrapGHJSON('/search/repositories', {
    sort: 'stars',
    order: 'desc',
    per_page: 100
  });
  getRepositoriesRaw = root.getRepositoriesRaw = function(properties, callback){
    var key;
    key = JSON.stringify(properties);
    console.log('getRepositoriesRaw ' + key);
    return repositories_db.get(key, function(err, val){
      if (val != null && properties.skipcache == null) {
        return callback(JSON.parse(val));
      } else {
        console.log('getRepositoriesRawUncached ' + key);
        return getRepositoriesRawUncached(properties, function(results){
          repositories_db.save(key, JSON.stringify(results), function(){});
          return callback(results);
        });
      }
    });
  };
  errWrap = function(f){
    return function(){
      var i$, args, callback;
      args = 0 < (i$ = arguments.length - 1) ? slice$.call(arguments, 0, i$) : (i$ = 0, []), callback = arguments[i$];
      return f(args, function(results){
        return callback(null, results);
      });
    };
  };
  getRepositories = root.getRepositories = function(lang, numPages, callback){
    var getPage;
    getPage = function(pageNum, callback){
      return getRepositoriesRaw({
        q: 'language:' + lang,
        page: pageNum
      }, function(results){
        return callback(null, results);
      });
    };
    return async.map((function(){
      var i$, to$, results$ = [];
      for (i$ = 1, to$ = numPages; i$ <= to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }()), getPage, function(errs, results){
      var output, i$, len$, page_results, j$, ref$, len1$, item;
      output = [];
      for (i$ = 0, len$ = results.length; i$ < len$; ++i$) {
        page_results = results[i$];
        for (j$ = 0, len1$ = (ref$ = page_results.items).length; j$ < len1$; ++j$) {
          item = ref$[j$];
          output.push(item.full_name);
        }
      }
      return callback(output);
    });
  };
  searchCodeRawUncached = root.searchCodeRawUncached = wrapGHJSON('/search/code', {
    order: 'desc',
    per_page: 100,
    headers: {
      Accept: 'application/vnd.github.v3.text-match+json'
    }
  });
  searchCodeRaw = root.searchCodeRaw = function(properties, callback){
    var key;
    key = JSON.stringify(properties);
    console.log('searchCodeRaw ' + key);
    return codesearch_db.get(key, function(err, val){
      if (val != null && properties.skipcache == null) {
        return callback(JSON.parse(val));
      } else {
        console.log('searchCodeRawUncached ' + key);
        return searchCodeRawUncached(properties, function(results){
          codesearch_db.save(key, JSON.stringify(results), function(){});
          return callback(results);
        });
      }
    });
  };
  sortCompare = function(a, b){
    switch (false) {
    case !(a > b):
      return 1;
    case !(a < b):
      return -1;
    default:
      return 0;
    }
  };
  searchCode = root.searchCode = function(searchTerm, lang, callback){
    return getRepositories(lang, 1, function(allrepos){
      var reposBy20, res$, i$, ref$, len$, i, searchInRepos;
      res$ = [];
      for (i$ = 0, len$ = (ref$ = (fn$())).length; i$ < len$; ++i$) {
        i = ref$[i$];
        res$.push(slice$.call(allrepos, 20 * i, 20 * (i + 1)));
      }
      reposBy20 = res$;
      searchInRepos = function(repos, callback){
        var reposText, x;
        reposText = (function(){
          var i$, ref$, len$, results$ = [];
          for (i$ = 0, len$ = (ref$ = repos).length; i$ < len$; ++i$) {
            x = ref$[i$];
            results$.push('repo:' + x);
          }
          return results$;
        }()).join(' ');
        return searchCodeRaw({
          q: searchTerm + ' in:file language:' + lang + ' ' + reposText
        }, function(results){
          return callback(null, results);
        });
      };
      return async.map(reposBy20, searchInRepos, function(errs, results){
        var output, i$, len$, repogroup_results, j$, ref$, len1$, item;
        output = [];
        for (i$ = 0, len$ = results.length; i$ < len$; ++i$) {
          repogroup_results = results[i$];
          for (j$ = 0, len1$ = (ref$ = repogroup_results.items).length; j$ < len1$; ++j$) {
            item = ref$[j$];
            output.push(item);
          }
        }
        output.sort(function(a, b){
          return sortCompare(a.score, b.score);
        });
        output.reverse();
        return callback(output);
      });
      function fn$(){
        var i$, to$, results$ = [];
        for (i$ = 0, to$ = Math.floor(allrepos.length / 20); i$ < to$; ++i$) {
          results$.push(i$);
        }
        return results$;
      }
    });
  };
  main = function(){
    return searchCode('sort', 'javascript', function(data){
      var x;
      return console.log((function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = data).length; i$ < len$; ++i$) {
          x = ref$[i$];
          results$.push(x.text_matches);
        }
        return results$;
      }()));
    });
  };
  if (require.main === module) {
    main();
  }
}).call(this);
